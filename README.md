# ClarityBlog-MatureIGA Repo

Welcome to the Clarity Blog - Mature IGA Repo! 

A few things before we get started. 

1. If you stumbled upon this repo outside of the Blog, Welcome! This repo is directly tied to a 
blog series that can be found here - https://claritysecurity.io/how-to-build-a-mature-iga/ 

2. The purpose of the blog and repo is to assist companies in developing an Identity Governance
program using python. The python scripts are extensible and robust enough to get started. However, 
these scripts are not supported by Clarity Security Corporation. If you are looking for a COTS
enterprise platform with premier support, Clarity Security is an enterprise IGA platform with prices 
starting at $2.00 / user per month. 

3. Sign up for the mailing list to receive notifications when the next chapter is published, scripts are updated, and new content
is made available - bit.ly/githubmatureiga.  

4. Watch this repo and receive a GitHub notification when commits occur.


# Project 1: Create an Identity Inventory

    Link to the blog: https://claritysecurity.io/how-to-build-a-mature-iga/

    Language(s): 
        Python 3.9 
    
    Libraries:  
        CSV - Default 
        JSON - Default
        XLSXWriter - https://pypi.org/project/XlsxWriter/
        Pandas - https://pypi.org/project/pandas/
    
    Notes: 
        IdentityInventory.py:
            Purpose: Combine disparate user listings (CSVs), generated by your applications, into a single CSV and JSON file. Each user has a single entry in the CSV and JSON, correlation occurs using full name. If you want correlation to be built around another attribute - e.g. Username or Email, change the function csvEvaluation in the following places: 
                
                Line 53 -> username or email = ''
                line 55 -> if len(headers[4]) > 1:
                line 56 -> username/email = row[headers[4][1]]
                line 57 and 58 -> delete.
                
                line 63 -> 86 ctrl h and replace fullName with username or email. 
            
            Input: CSV(s) with the following information:
                Name (Full or First and Last)
                Email / Username
                Application Name
                Manager (If able, not required)
                User Creation Date (Not required)
                User Account Status (Not required, highly recommended)
            
            Output: 2 Files:
                1 JSON file that is a json.dumps of the identity dictionary.
                1 CSV file that is the exploded identity dictionary. 
        
            Functions:
                collectFileNames(): Prompts you for the number of files and their names. Returns a list named "fileNames"
                csvEvaluation(file, identities): Processes the data in each CSV
                    Line 24 - 33 Opens the CSV
                    Line 35 - 39 Identifies the contents of each column by printing out the first value (header)
                    Line 51 - 88 Processes the contents of the file.
                        Line 55 - 61 begins populating the dictionary - identities. The dictionary structure is: 
                            Identities -> 
                                Keys -> User's Full Names
                                    Value -> Nested Dictionary ->
                                        Sub Keys -> String - Column headers (defined on line 18).
                                            Sub Values -> List of Strings -> content we are evaluating. 
                            
                            Example to fetch a sub value: 
                                print(Identities["Alexis Borchgrevink"]["Manager"]) --> ["Greg Glass", "Stephanie Burns"]
                            
                            Visualized: 
                                {'Alexis Borchgrevink': {'Manager/Reviewer': ['Greg Glass', 'Steph Burns'], 'Full Name': ['Alexis Borchgrevink'], 'First Name': ['Alexis'], 'Last Name': ['Borchgrevink'], 'Email': ['alexis@claritysecurity.io'], 'Application': ['HR AD'], 'User Creation Date': ['10/21/2022'], 'User Account Status': ['-'], 'Other': ['-'], 'Manager Response (Drop Down)': ['Employed']}
                            
                main(): Instantiates our required dictionaries, establishes the headers, and writes the final JSON file and CSV. 
    
        ManagerUserReview.py:
        
            Purpose: Takes the file - identityInventory.json and converts it into individual excel files for each manager to review.
            
            Input: IdentityInventory.json
            
            Output: N Excel (.xlsx) Spreadsheets.  
           
            Functions:
                collectIdentitiesFromJson(fileName, managers): Collects the json file and reconstructs the identity dictionary to user Manager as the key (instead of the identity identifier). 
                writeManagerReviews(managers): Takes the newly restructured dictionary and writes it to individual excel sheets using XLSXWriter. 
                    Name of the excel sheet is set on line 39 -> manager key + '.xlsx' (nothing fancy). 
                    The headers are written in row 1. 
                    The remaining data in the dictionary[manager] is written to that sheet. 
                    Data validation is added to the final column on each row. It allows managers to click and select their response to each item instead of typing it in. It makes the last script possible. If you want to change the available responses, you need to update UserReviewCombiner.py lines 46 through 94. 
                managersToJson(managers): json.dumps the manager dictionary we have been working with to a json file titled managers.json. 
                main(): Instantiates the managers dictionary and initiates the rest of the functions. 
        
    
        UserReviewCombiner.py:
        
            Purpose: Combine the manager responses from the disparate excel sheets into a master book + sheets separated by required action.  
                        
            Input: Excel sheets from each reviewer & managers.json
            
            Output: MasterUserreviewResponse.xlsx -> a single excel book with every response and required actions. 
           
            Functions:
                readExcelReturnDict(fileName, responseDict): Using Pandas read_excel, DataFrame and to_dict capabilities, we ingest each excel sheet as a dataframe, and convert it to a temporary python dictionary. 
                loadManagerJson(fileName): collect the names of each excel sheet via the keys in the file managers.json.
                createSheetsAddHeaders(headerNames, workbook, sheetInfo): This creates the individual sheets and adds the headers in the master excel book.
                populateSheet(workbook, sheetName, manager, row, col, content): Writes the content to the various pages. XLSXWriter cannot write lists, on line 34 we convert the list into a string delimited by '&'.
                createExcel(managers): Function to create the excel.
                    Lines 42 - 49 Establish the headers and a dictionary to know the next row to write on (sheetInfo line 46).
                    Lines 52 - 54 Create the excel book. 
                    Lines 56 - 70 Reconstruct the manager dictionary to use user's name as the key. 
                    Lines 72 - 81 Evaluate the managers' responses and identify any conflicting responses. 
                    Lines 83 - 94 Write the users to master and the correct remediation page. 
                main():coordinate. 
